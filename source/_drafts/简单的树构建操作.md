---
title: 简单的树构建操作
date: 2017-06-12 21:32:41
tags:
---

## 综述

日常开发中常会遇到有相互隶属关系的同种数据，例如用户权限，网站地图，文档目录，以及一些动态的分类方式等，甚至是pypi上的项目引用关系。此时相信大家都明白，应该使用的数据结构是树。


大家都知道使用树，那如何用得好，不至于走岔迷失呢？在我看来，重点一是在于**方便寻址**，根据业务需要，在创建树的同时创建好一个或多个适用的索引表；二是将树**可视化、形象化**，通过添加节点特征，规范变量名，或者建立可靠的序列化输出机制，从而便于程序判断和debug。 这两点非常有助于程序猿快速建立对这个树的直观映像，并提升代码的表达能力。


相信我，一个好的程序猿应该拥有的素质，不是在复杂的数据结构中绕来绕去而不晕的能力，而是将一个看似复杂的数据结构快速梳理出线索，使其简单可靠的能力。而运用好之前提到的两点，就如同在几何题中做出了关键辅助线。

## 实践一

产品中有帮助系统，帮助文档的目录是一个简单的三层结构：产品，子目录，页面。

早年的目录结构是页面存在数据库中，子目录和产品的关系以字典结构直接写在代码中。后来又重构成了目录结构都以节点方式放在数据库，在代码中创建为树。
```javascript
/* 数据样例 */
{id: 0, name: 'some help menu'}
{id: 1, name: 'yet a menu', root: 0}
{id: 2, name: 'menu x', root: 1}
{id: 3, name: 'another', root: 0}
{id: 4, name: 'some other product'}

```

但是这里有个问题，这段代码中每当需要使用到某一确定id的帮助文档时，总是在树中进行深度优先查找，嵌套多层循环。反向查找其父级内容创建面包屑时，又是在节点列表中不断循环查找其id和当前节点父级id相同的节点，直到父级id属性为空。这种自找麻烦的情况在展示搜索帮助文档内容时达到峰值，页面需要一个新的缩小的树状结构用于展示搜索结果的分布情况并计数，代码中进行的判断和循环多达6次缩进。请注意，在学校教过树的搜索是深度优先和广度优先。但是，我们使用时千万不要轻易在树中搜索。我们需要的是捷径。


我们来看看我们对此数据结构的需求是什么样的：
* 页面上有个树形的帮助文档索引需要展示
* 帮助目录只会有3层，短期内不会有其他更改
* 当显示某个确定的帮助文档时，需要展示面包屑导航栏
* 对帮助进行搜索，展示时树中仅显示被命中的项目，并对每个分类被搜索到的项目计数

为了能实现这个简单的需求，我们需要一个有索引的树。

首先，我们定义一个类，这个类的功能很简单，就是生成目录树，实例化完毕后，其`tree`属性就是一个描述树图的大字典，`id_index`属性则是一个id索引，另外，还在数据内部添加了一点标记。如下：

```python
self.tree = {
    'id_0': {
        ...   # root content
        menu_level: 0,
        children: {
            'menu_id': { ..., children: {...}}
            'menu_id': { ..., children: {...}}
            }
        }
    }
self.id_index = {
    'id_0': root_data,  # 即self.tree中root_
    'id_1': data_1,  # 即self.tree中children下的dict对象
    'id_2': data_2,
    'id_3': data_3,
    ...,
    }
```
这里用到了python中对可变对象的名字引用，这样的数据结构有个好处，就是可以根据id快速定位到某个帮助页面，同时根据获得的这个字典对象在树形图中快速寻找其下级目录，或者根据其root属性再次在index中定位其父级页面。

生成代码大致如下：

```python
# 生成一个简单的树

class HelpMenuTree(object):

    def __init__(self, node_list):
        self.tree = {}
        self.id_index = {}
        self.__build(node_list)

    def __build(self, node_list):
        menu_level = 0
        origin_len = len(node_list)
        while len(node_list):
            tmp_id_index = {}
            for node in node_list[:]:
                parent = None
                if not node.get('root'):    # 首次循环检查root节点
                    parent = self.tree
                elif node['root'] in self.id_index:  # 之后每次获取一层的节点
                    parent = self.id_index[node['root']].setdefault('children', {})
                if parent:
                    parent[node['id']] = tmp_id_index[node['id']] = node
                    node['menu_level'] = menu_level
                    node_list.remove(node)
            self.id_index.update(tmp_id_index)  # 循环完毕一层的节点之后，更新到id_index
            menu_level += 1
            if origin_len == len(node_list):
                break      # 如果列表长度没变化，说明剩下的都是孤立节点，丢弃，或许可以打个日志
            origin_len = len(node_list)

```

在这段代码为我们生成一个足够简单好用的树，我们可以为其添加一些方便的方法，比如：

```python
    def make_bread(self, help_id):
        """ 为help文档创建面包屑"""
        if help_id not in self.id_index:
            raise ValueError('...')
        bread_list = []
        target_id = help_id
        while target_id:
            target = self.id_index[target_id]
            bread_list.append(target)
            target_id = target.get('root')
```

从这个例子，我们可以显而易见的发现索引的好处。同理可见于实践二。


## 实践二

我们产品后台的Django系统中历来权限控制极为混乱，权限散落于各个页面，书写的权限与具体功能无法一一对应，亟待解决。经历某些事件，痛定思痛之后，决定重新创建一套权限系统。

首先，研究Django系统的特性之后，决定直接利用框架URL路由系统来作为权限系统的根基。先整理URL命名以吻合整个后台的页面层级，然后以路由树直接复刻出整个网站地图，从而可以通过这个树直观感受整个后台。我们在此创建出两个类，节点类及网络类，用以控制这整个树结构。创建树的逻辑很简单：


```python
class NodeNetwork(object):

    def __init__(self, router_dict):
        self.root_node = RouterNode('', root_node=True)
        self.__path_map = {}
        self.__build_network_by_dict(self.root_node, router_dict)
        self.__point_map = {
            node.node_value: node for node in self.__path_map.values()
        }

     def __build_network_by_dict(self, root, router_dict):
         for key, value in router_dict.items():
             try:
                 new_node = RouterNode(key, parent=root)
             except IgnoredPermission:
                 continue
             if isinstance(value, dict):
                 self.__build_network_by_dict(new_node, value)
             elif isinstance(value, basestring):
                 new_node.become_leaf(value)
             self.__path_map[new_node.full_path] = new_node

```
